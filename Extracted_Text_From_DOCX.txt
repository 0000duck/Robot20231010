Розробка алгоритму руху роботів.
Мета: Ознайомлення з засобами розробки Visual Studio та Resharper. Після виконання лабораторної студент повинен уміти створювати проекти, підключати бібліотеки, відлагоджувати програми.
Опис. На карті розміром 100 на 100 є ресурси енергії та роботи які їх збирають. Кожен студент реалізує алгоритм за яким його роботи рухатимуться, збиратимуть ресурси та створюватимуть нових роботів. Лабораторна є конкурсною, тобто на одній карті будуть одночасно роботи усіх студентів, що здають лабораторну. Кількість балів за лабораторну залежить від кількості ресурсів, який зібрали роботи за 50 ходів усіх роботів.
Опис конкурсу.
Карта є квадратною розміром 100x100, тобто її клітинки мають координати (x,y), де x та y можуть набувати значень від 0 до 99. За межі карти вийти неможливо, і при такій спробі робот просто пропускає хід. На одній клітинці може перебувати лише один робот.
Робота алгоритму. Випадковим чином визначається чиї роботи будуть іти першими, чиї другими, третіми і т.д. Спочатку діє перший робот першого учасника, потім перший робот другого учасника, потім перший робот третього учасника, і т.д. Потім діє другий робот першого учасника, другий робот другого учасника, другий робот третього учасника, і т.д. Хід закінчується коли усі роботи виконали дію. Робот може виконати тільки одну з трьох дій: рухатись на якусь клітинку, збирати ресурси на станції, створити нового робота. Для дії робота йому передається уся інформація карти. Деталі реалізації алгоритму нижче.
Рух роботів потребує енергії, яка рівна квадрату відстані між початковою і кінцевою клітинками, та визначається за формулою E = (x1 – x0)2 + (y1 – y0)2 , де (x0, y0) – точка на якій знаходиться робот перед початком руху, (x1, y1) – точка у яку має намір прийти робот. Таким чином, чим швидше рухається робот тим більше енергії він витрачає. Для прикладу: якщо робот переміщується на 5 клітинок по вісі X за один хід, то він витратить 52 = 25 одиниць енергії. Якщо він рухатиметься по лише одній клітинці 5 ходів, то він витратить лише 12 +12+12+12+12= 5 одиниць енергії. Якщо у робота менше енергії ніж рух необхідно, то дія робота ігнорується і він залишається на місці. Увага! Якщо на клітинці уже стоїть інший (свій або чужий) робот, то робот “спихає” його на сусідню вільну клітинку, витрачаючи при цьому 10 одиниць енергії (якщо у нього вона є, в протилежному випадкувін втрачає хід). Робот, якого “спихнули” з клітинки, не витрачає енергії. Можливі певні відмінності, у залежності від варіанту (див. нижче свій варіант).
Енергія можуть бути отримана із зарядних станцій, які її накопичують та генерують. На клітинці карти може бути розташована тільки одна станція. Для того щоби отримати цю енергію робот повинен стати на клітинку зі станцією і збирати заряд ( або на певній відстані– залежить від варіанту). Максимальна енергія, яку накопичують станції рівна 1000. Кожен хід станції генерують від 10 до 20 одиниць енергії. За один хід робот може зібрати максимально 200 одиниць енергії з одної станції. Для різних варіантів можуть біти відмінності у константах. На початку станції не мають енергії.
Створення нових роботів також потребує енергії. Новий робот матиме енергію 100 (по замовчуванню, але можна задати інше значення), і з’являється на сусідній вільній клітинці. Робот, що створив нового робота втрачає 200 одиниць енергії + енергію, що є у нового робота (100 по замовчуванню). Для того щоб створити нового робота, у батьківського робота повинно бути не менше цієї енергії, інакше дія робота буде ігноруватись. Рекомендується залишати батьківському принаймі 100 одиниць енергії. Для різних варіантів можуть біти відмінності у константах. Максимальна кількість своїх роботів – 100.
Початкові умови. Кожному учаснику надається 10 роботів із енергією 100, розташованих у випадкових місцях на карті. Кількість станцій є у 5 разів більшою ніж кількість роботів. Станції у початковий відлік часу не мають енергії і тільки починають її накопичувати.

У бібліотеці є класи карти (Map), позиції (Position), робота (Robot), команди для роботів, і інтерфейс IRobotAlgorithm, який повинен бути реалізований. Наш клас повинен наслідувати цей алгоритм, тобто ставимо дві крапки і назву IRobotAlgorithm.
Отже, залишилось реалізувати метод DoStep, який отримає усю інформацію та повертає команду. Команди які може робити робот, які мають спільний інтерфейс IRobotCommand із єдиним методом Apply.

Кожна з цих команд не має додаткових параметрів дії, окрім команди MoveCommand яка має властивість NewPosition, тобто точку в яку потрібно йти даному роботу.
Реалізація алгоритму
Як приклад, реалізуємо дуже простий варіант алгоритму. Нехай робот знаходить найближчу станцію, не зайняту іншими роботами, і рухається до неї зі сталою швидкістю. Якщо він знаходить на станції, то нехай там і залишається. Для цього нам необхідно запрограмувати функцію, яка повертає найближчу незайняту станцію.
Додамо її в окремий допоміжний клас. Для цього в панелі “Solution Explorer” за допомогою миші викличемо контекстне меню, і виберемо пункт Add>Class. Переіменуємо його в DistanceHelper.
Напишемо нашу допоміжну функцію.
class DistanceHelper
{
public static int FindDistance(Position	a, Position b)
{
return (int)(Math.Pow(a.X - b.X, 2)	+ Math.Pow(a.Y - b.Y, 2));
}
}
Пояснимо код, описаний вище. Ми робимо функцію FindDistance статичною, оскільки нам не треба ініціалізувати клас DistanceHelper. Функція приймає вхідні аргументи у якості двох позицій на карті і рахує відстань між ними, повертаючи ціле число. Ми використовуємо допоміжний клас System.Math для обчислення квадрату. Оскільки він повертає число з плавачою комою, то конвертуємо його у ціле.
Тепер напишемо допоміжні функції. Для цього реалізуємо функції : IsStationFree – функцію, яка визначає чи станція незайнята; FindNearestFreeStation – функцію, яка визначає найближчу вільну станцію, і відповідно наш алгоритм.
public Position FindNearestFreeStation(Robot.Common.Robot movingRobot, Map map, IList<Robot.Common.Robot> robots)
{
EnergyStation nearest = null;
int minDistance = int.MaxValue;
foreach (var station in map.Stations) { if (IsStationFree(station, movingRobot, robots)) { int d = DistanceHelper.FindDistance(station.Position, movingRobot.Position);
if (d < minDistance) { minDistance = d; nearest = station;
}
}
}
return nearest == null ? null : nearest.Position; }
public bool IsStationFree(EnergyStation station, Robot.Common.Robot movingRobot, IList<Robot.Common.Robot> robots)
{ return IsCellFree(station.Position, movingRobot, robots);
}
public bool IsCellFree(Position cell, Robot.Common.Robot movingRobot, IList<Robot.Common.Robot> robots) {
foreach (var robot in robots)
{
if (robot != movingRobot)
{
if (robot.Position == cell) return false;
}
} return true;
}
Нарешті переходимо до реалізації алгоритму. Спочатку зі списку усіх роботів виділяємо нашого робота (змінна movingRobot). Якщо у нього достатньо енергії (більше 500 одиниць), то створюємо робота. Якщо робот стоїть на станції, то збираємо енергію, в протилежному разі повземо по одній клітинці до станції.
public RobotCommand DoStep(IList<Robot.Common.Robot> robots, int robotToMoveIndex, Map map) {
Robot.Common.Robot movingRobot = robots[robotToMoveIndex];
if ((movingRobot.Energy >	500)	&& (robots.Count < map.Stations.Count))
{
return new CreateNewRobotCommand();
}
Position stationPosition = FindNearestFreeStation(robots[robotToMoveIndex], map, robots);

if (stationPosition == null) return null;
if (stationPosition == movingRobot.Position) return new CollectEnergyCommand();
else {
return new MoveCommand(){NewPosition = stationPosition };
}
}
Після реалізації, першим кроком у вдосконаленні алгоритму, подумайте як використати метод FindDistance класу DistanceHelper, щоб оптимізувати рух робота.
ЗАВДАННЯ:

Станцій у 5 разів більше ніж усіх роботів на початку змагання, кожна з яких генерує від 50 до 100 одиниць енергії за хід. Максимальне значення енергії станції 20000. Роботи можуть збирати енергію зі всіх станцій на відстані 2 клітинок, але не більше 40 з одної станції за хід. Енергія втрат при створенні нового робота рівна 100. За кожні 15 000 очок ставиться 1 бал.

